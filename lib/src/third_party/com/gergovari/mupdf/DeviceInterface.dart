// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: file_names
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: overridden_fields
// ignore_for_file: unnecessary_cast
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name

import "dart:isolate" show ReceivePort;
import "dart:ffi" as ffi;
import "package:jni/internal_helpers_for_jnigen.dart";
import "package:jni/jni.dart" as jni;

import "../../artifex/mupdf/fitz/Path.dart" as path_;

import "../../artifex/mupdf/fitz/Matrix.dart" as matrix_;

import "../../artifex/mupdf/fitz/ColorSpace.dart" as colorspace_;

import "../../artifex/mupdf/fitz/StrokeState.dart" as strokestate_;

import "../../artifex/mupdf/fitz/Text.dart" as text_;

import "../../artifex/mupdf/fitz/Shade.dart" as shade_;

import "../../artifex/mupdf/fitz/Image.dart" as image_;

import "../../artifex/mupdf/fitz/Rect.dart" as rect_;

import "../../artifex/mupdf/fitz/DefaultColorSpaces.dart"
    as defaultcolorspaces_;

/// from: com.gergovari.mupdf.DeviceInterface
class DeviceInterface extends jni.JObject {
  @override
  late final jni.JObjType<DeviceInterface> $type = type;

  DeviceInterface.fromRef(
    jni.JObjectPtr ref,
  ) : super.fromRef(ref);

  static final _class =
      jni.Jni.findJClass(r"com/gergovari/mupdf/DeviceInterface");

  /// The type which includes information such as the signature of this class.
  static const type = $DeviceInterfaceType();
  static final _id_close =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"close", r"()V");

  /// from: public abstract void close()
  void close() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_close, jni.JniCallType.voidType, []).check();
  }

  static final _id_fillPath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"fillPath",
      r"(Lcom/artifex/mupdf/fitz/Path;ZLcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V");

  /// from: public abstract void fillPath(com.artifex.mupdf.fitz.Path path, boolean z, com.artifex.mupdf.fitz.Matrix matrix, com.artifex.mupdf.fitz.ColorSpace colorSpace, float[] fs, double f, int i)
  void fillPath(
    path_.Path path,
    bool z,
    matrix_.Matrix matrix,
    colorspace_.ColorSpace colorSpace,
    jni.JArray<jni.jfloat> fs,
    double f,
    int i,
  ) {
    return jni.Jni.accessors
        .callMethodWithArgs(reference, _id_fillPath, jni.JniCallType.voidType, [
      path.reference,
      z ? 1 : 0,
      matrix.reference,
      colorSpace.reference,
      fs.reference,
      f,
      jni.JValueInt(i)
    ]).check();
  }

  static final _id_clipPath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"clipPath",
      r"(Lcom/artifex/mupdf/fitz/Path;ZLcom/artifex/mupdf/fitz/Matrix;)V");

  /// from: public abstract void clipPath(com.artifex.mupdf.fitz.Path path, boolean z, com.artifex.mupdf.fitz.Matrix matrix)
  void clipPath(
    path_.Path path,
    bool z,
    matrix_.Matrix matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_clipPath,
        jni.JniCallType.voidType,
        [path.reference, z ? 1 : 0, matrix.reference]).check();
  }

  static final _id_strokePath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"strokePath",
      r"(Lcom/artifex/mupdf/fitz/Path;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V");

  /// from: public abstract void strokePath(com.artifex.mupdf.fitz.Path path, com.artifex.mupdf.fitz.StrokeState strokeState, com.artifex.mupdf.fitz.Matrix matrix, com.artifex.mupdf.fitz.ColorSpace colorSpace, float[] fs, double f, int i)
  void strokePath(
    path_.Path path,
    strokestate_.StrokeState strokeState,
    matrix_.Matrix matrix,
    colorspace_.ColorSpace colorSpace,
    jni.JArray<jni.jfloat> fs,
    double f,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_strokePath, jni.JniCallType.voidType, [
      path.reference,
      strokeState.reference,
      matrix.reference,
      colorSpace.reference,
      fs.reference,
      f,
      jni.JValueInt(i)
    ]).check();
  }

  static final _id_clipStrokePath = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"clipStrokePath",
      r"(Lcom/artifex/mupdf/fitz/Path;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;)V");

  /// from: public abstract void clipStrokePath(com.artifex.mupdf.fitz.Path path, com.artifex.mupdf.fitz.StrokeState strokeState, com.artifex.mupdf.fitz.Matrix matrix)
  void clipStrokePath(
    path_.Path path,
    strokestate_.StrokeState strokeState,
    matrix_.Matrix matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_clipStrokePath,
        jni.JniCallType.voidType,
        [path.reference, strokeState.reference, matrix.reference]).check();
  }

  static final _id_fillText = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"fillText",
      r"(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V");

  /// from: public abstract void fillText(com.artifex.mupdf.fitz.Text text, com.artifex.mupdf.fitz.Matrix matrix, com.artifex.mupdf.fitz.ColorSpace colorSpace, float[] fs, double f, int i)
  void fillText(
    text_.Text text,
    matrix_.Matrix matrix,
    colorspace_.ColorSpace colorSpace,
    jni.JArray<jni.jfloat> fs,
    double f,
    int i,
  ) {
    return jni.Jni.accessors
        .callMethodWithArgs(reference, _id_fillText, jni.JniCallType.voidType, [
      text.reference,
      matrix.reference,
      colorSpace.reference,
      fs.reference,
      f,
      jni.JValueInt(i)
    ]).check();
  }

  static final _id_clipText = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"clipText",
      r"(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;)V");

  /// from: public abstract void clipText(com.artifex.mupdf.fitz.Text text, com.artifex.mupdf.fitz.Matrix matrix)
  void clipText(
    text_.Text text,
    matrix_.Matrix matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_clipText,
        jni.JniCallType.voidType, [text.reference, matrix.reference]).check();
  }

  static final _id_strokeText = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"strokeText",
      r"(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V");

  /// from: public abstract void strokeText(com.artifex.mupdf.fitz.Text text, com.artifex.mupdf.fitz.StrokeState strokeState, com.artifex.mupdf.fitz.Matrix matrix, com.artifex.mupdf.fitz.ColorSpace colorSpace, float[] fs, double f, int i)
  void strokeText(
    text_.Text text,
    strokestate_.StrokeState strokeState,
    matrix_.Matrix matrix,
    colorspace_.ColorSpace colorSpace,
    jni.JArray<jni.jfloat> fs,
    double f,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_strokeText, jni.JniCallType.voidType, [
      text.reference,
      strokeState.reference,
      matrix.reference,
      colorSpace.reference,
      fs.reference,
      f,
      jni.JValueInt(i)
    ]).check();
  }

  static final _id_clipStrokeText = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"clipStrokeText",
      r"(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;)V");

  /// from: public abstract void clipStrokeText(com.artifex.mupdf.fitz.Text text, com.artifex.mupdf.fitz.StrokeState strokeState, com.artifex.mupdf.fitz.Matrix matrix)
  void clipStrokeText(
    text_.Text text,
    strokestate_.StrokeState strokeState,
    matrix_.Matrix matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_clipStrokeText,
        jni.JniCallType.voidType,
        [text.reference, strokeState.reference, matrix.reference]).check();
  }

  static final _id_ignoreText = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"ignoreText",
      r"(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;)V");

  /// from: public abstract void ignoreText(com.artifex.mupdf.fitz.Text text, com.artifex.mupdf.fitz.Matrix matrix)
  void ignoreText(
    text_.Text text,
    matrix_.Matrix matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_ignoreText,
        jni.JniCallType.voidType, [text.reference, matrix.reference]).check();
  }

  static final _id_fillShade = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"fillShade",
      r"(Lcom/artifex/mupdf/fitz/Shade;Lcom/artifex/mupdf/fitz/Matrix;DI)V");

  /// from: public abstract void fillShade(com.artifex.mupdf.fitz.Shade shade, com.artifex.mupdf.fitz.Matrix matrix, double f, int i)
  void fillShade(
    shade_.Shade shade,
    matrix_.Matrix matrix,
    double f,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_fillShade,
        jni.JniCallType.voidType,
        [shade.reference, matrix.reference, f, jni.JValueInt(i)]).check();
  }

  static final _id_fillImage = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"fillImage",
      r"(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;DI)V");

  /// from: public abstract void fillImage(com.artifex.mupdf.fitz.Image image, com.artifex.mupdf.fitz.Matrix matrix, double f, int i)
  void fillImage(
    image_.Image image,
    matrix_.Matrix matrix,
    double f,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_fillImage,
        jni.JniCallType.voidType,
        [image.reference, matrix.reference, f, jni.JValueInt(i)]).check();
  }

  static final _id_fillImageMask = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"fillImageMask",
      r"(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V");

  /// from: public abstract void fillImageMask(com.artifex.mupdf.fitz.Image image, com.artifex.mupdf.fitz.Matrix matrix, com.artifex.mupdf.fitz.ColorSpace colorSpace, float[] fs, double f, int i)
  void fillImageMask(
    image_.Image image,
    matrix_.Matrix matrix,
    colorspace_.ColorSpace colorSpace,
    jni.JArray<jni.jfloat> fs,
    double f,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_fillImageMask, jni.JniCallType.voidType, [
      image.reference,
      matrix.reference,
      colorSpace.reference,
      fs.reference,
      f,
      jni.JValueInt(i)
    ]).check();
  }

  static final _id_clipImageMask = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"clipImageMask",
      r"(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;)V");

  /// from: public abstract void clipImageMask(com.artifex.mupdf.fitz.Image image, com.artifex.mupdf.fitz.Matrix matrix)
  void clipImageMask(
    image_.Image image,
    matrix_.Matrix matrix,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_clipImageMask,
        jni.JniCallType.voidType, [image.reference, matrix.reference]).check();
  }

  static final _id_popClip =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"popClip", r"()V");

  /// from: public abstract void popClip()
  void popClip() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_popClip, jni.JniCallType.voidType, []).check();
  }

  static final _id_beginMask = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"beginMask",
      r"(Lcom/artifex/mupdf/fitz/Rect;ZLcom/artifex/mupdf/fitz/ColorSpace;[FI)V");

  /// from: public abstract void beginMask(com.artifex.mupdf.fitz.Rect rect, boolean z, com.artifex.mupdf.fitz.ColorSpace colorSpace, float[] fs, int i)
  void beginMask(
    rect_.Rect rect,
    bool z,
    colorspace_.ColorSpace colorSpace,
    jni.JArray<jni.jfloat> fs,
    int i,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_beginMask, jni.JniCallType.voidType, [
      rect.reference,
      z ? 1 : 0,
      colorSpace.reference,
      fs.reference,
      jni.JValueInt(i)
    ]).check();
  }

  static final _id_endMask =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"endMask", r"()V");

  /// from: public abstract void endMask()
  void endMask() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_endMask, jni.JniCallType.voidType, []).check();
  }

  static final _id_beginGroup = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"beginGroup",
      r"(Lcom/artifex/mupdf/fitz/Rect;Lcom/artifex/mupdf/fitz/ColorSpace;ZZIF)V");

  /// from: public abstract void beginGroup(com.artifex.mupdf.fitz.Rect rect, com.artifex.mupdf.fitz.ColorSpace colorSpace, boolean z, boolean z1, int i, float f)
  void beginGroup(
    rect_.Rect rect,
    colorspace_.ColorSpace colorSpace,
    bool z,
    bool z1,
    int i,
    double f,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_beginGroup, jni.JniCallType.voidType, [
      rect.reference,
      colorSpace.reference,
      z ? 1 : 0,
      z1 ? 1 : 0,
      jni.JValueInt(i),
      jni.JValueFloat(f)
    ]).check();
  }

  static final _id_endGroup =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"endGroup", r"()V");

  /// from: public abstract void endGroup()
  void endGroup() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_endGroup, jni.JniCallType.voidType, []).check();
  }

  static final _id_beginTile = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"beginTile",
      r"(Lcom/artifex/mupdf/fitz/Rect;Lcom/artifex/mupdf/fitz/Rect;FFLcom/artifex/mupdf/fitz/Matrix;I)I");

  /// from: public abstract int beginTile(com.artifex.mupdf.fitz.Rect rect, com.artifex.mupdf.fitz.Rect rect1, float f, float f1, com.artifex.mupdf.fitz.Matrix matrix, int i)
  int beginTile(
    rect_.Rect rect,
    rect_.Rect rect1,
    double f,
    double f1,
    matrix_.Matrix matrix,
    int i,
  ) {
    return jni.Jni.accessors
        .callMethodWithArgs(reference, _id_beginTile, jni.JniCallType.intType, [
      rect.reference,
      rect1.reference,
      jni.JValueFloat(f),
      jni.JValueFloat(f1),
      matrix.reference,
      jni.JValueInt(i)
    ]).integer;
  }

  static final _id_endTile =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"endTile", r"()V");

  /// from: public abstract void endTile()
  void endTile() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_endTile, jni.JniCallType.voidType, []).check();
  }

  static final _id_renderFlags = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"renderFlags", r"(II)V");

  /// from: public abstract void renderFlags(int i, int i1)
  void renderFlags(
    int i,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_renderFlags,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), jni.JValueInt(i1)]).check();
  }

  static final _id_setDefaultColorSpaces = jni.Jni.accessors.getMethodIDOf(
      _class.reference,
      r"setDefaultColorSpaces",
      r"(Lcom/artifex/mupdf/fitz/DefaultColorSpaces;)V");

  /// from: public abstract void setDefaultColorSpaces(com.artifex.mupdf.fitz.DefaultColorSpaces defaultColorSpaces)
  void setDefaultColorSpaces(
    defaultcolorspaces_.DefaultColorSpaces defaultColorSpaces,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_setDefaultColorSpaces,
        jni.JniCallType.voidType,
        [defaultColorSpaces.reference]).check();
  }

  static final _id_beginLayer = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"beginLayer", r"(Ljava/lang/String;)V");

  /// from: public abstract void beginLayer(java.lang.String s)
  void beginLayer(
    jni.JString s,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_beginLayer,
        jni.JniCallType.voidType, [s.reference]).check();
  }

  static final _id_endLayer =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"endLayer", r"()V");

  /// from: public abstract void endLayer()
  void endLayer() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_endLayer, jni.JniCallType.voidType, []).check();
  }

  static final _id_beginStructure = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"beginStructure", r"(ILjava/lang/String;I)V");

  /// from: public abstract void beginStructure(int i, java.lang.String s, int i1)
  void beginStructure(
    int i,
    jni.JString s,
    int i1,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(
        reference,
        _id_beginStructure,
        jni.JniCallType.voidType,
        [jni.JValueInt(i), s.reference, jni.JValueInt(i1)]).check();
  }

  static final _id_endStructure = jni.Jni.accessors
      .getMethodIDOf(_class.reference, r"endStructure", r"()V");

  /// from: public abstract void endStructure()
  void endStructure() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_endStructure, jni.JniCallType.voidType, []).check();
  }

  static final _id_beginMetatext = jni.Jni.accessors.getMethodIDOf(
      _class.reference, r"beginMetatext", r"(ILjava/lang/String;)V");

  /// from: public abstract void beginMetatext(int i, java.lang.String s)
  void beginMetatext(
    int i,
    jni.JString s,
  ) {
    return jni.Jni.accessors.callMethodWithArgs(reference, _id_beginMetatext,
        jni.JniCallType.voidType, [jni.JValueInt(i), s.reference]).check();
  }

  static final _id_endMetatext =
      jni.Jni.accessors.getMethodIDOf(_class.reference, r"endMetatext", r"()V");

  /// from: public abstract void endMetatext()
  void endMetatext() {
    return jni.Jni.accessors.callMethodWithArgs(
        reference, _id_endMetatext, jni.JniCallType.voidType, []).check();
  }

  /// Maps a specific port to the implemented methods.
  static final Map<int, Map<String, Function>> _$methods = {};

  /// Maps a specific port to the type parameters.
  static final Map<int, Map<String, jni.JObjType>> _$types = {};

  ReceivePort? _$p;

  static final Finalizer<ReceivePort> _$finalizer = Finalizer(($p) {
    _$methods.remove($p.sendPort.nativePort);
    _$types.remove($p.sendPort.nativePort);
    $p.close();
  });

  @override
  void delete() {
    _$methods.remove(_$p?.sendPort.nativePort);
    _$types.remove(_$p?.sendPort.nativePort);
    _$p?.close();
    _$finalizer.detach(this);
    super.delete();
  }

  static jni.JObjectPtr _$invoke(
    int port,
    jni.JObjectPtr descriptor,
    jni.JObjectPtr args,
  ) {
    return _$invokeMethod(
      port,
      $MethodInvocation.fromAddresses(
        0,
        descriptor.address,
        args.address,
      ),
    );
  }

  static final ffi.Pointer<
          ffi.NativeFunction<
              jni.JObjectPtr Function(
                  ffi.Uint64, jni.JObjectPtr, jni.JObjectPtr)>>
      _$invokePointer = ffi.Pointer.fromFunction(_$invoke);

  static ffi.Pointer<ffi.Void> _$invokeMethod(
    int $p,
    $MethodInvocation $i,
  ) {
    final $d = $i.methodDescriptor.toDartString(deleteOriginal: true);
    final $a = $i.args;
    if ($d == r"close()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    if ($d ==
        r"fillPath(Lcom/artifex/mupdf/fitz/Path;ZLcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const path_.$PathType(), deleteOriginal: true),
        $a[1]
            .castTo(const jni.JBooleanType(), deleteOriginal: true)
            .booleanValue(deleteOriginal: true),
        $a[2].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[3].castTo(const colorspace_.$ColorSpaceType(), deleteOriginal: true),
        $a[4].castTo(const jni.JArrayType(jni.JFloatType()),
            deleteOriginal: true),
        $a[5]
            .castTo(const jni.JDoubleType(), deleteOriginal: true)
            .doubleValue(deleteOriginal: true),
        $a[6]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"clipPath(Lcom/artifex/mupdf/fitz/Path;ZLcom/artifex/mupdf/fitz/Matrix;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const path_.$PathType(), deleteOriginal: true),
        $a[1]
            .castTo(const jni.JBooleanType(), deleteOriginal: true)
            .booleanValue(deleteOriginal: true),
        $a[2].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"strokePath(Lcom/artifex/mupdf/fitz/Path;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const path_.$PathType(), deleteOriginal: true),
        $a[1].castTo(const strokestate_.$StrokeStateType(),
            deleteOriginal: true),
        $a[2].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[3].castTo(const colorspace_.$ColorSpaceType(), deleteOriginal: true),
        $a[4].castTo(const jni.JArrayType(jni.JFloatType()),
            deleteOriginal: true),
        $a[5]
            .castTo(const jni.JDoubleType(), deleteOriginal: true)
            .doubleValue(deleteOriginal: true),
        $a[6]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"clipStrokePath(Lcom/artifex/mupdf/fitz/Path;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const path_.$PathType(), deleteOriginal: true),
        $a[1].castTo(const strokestate_.$StrokeStateType(),
            deleteOriginal: true),
        $a[2].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"fillText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const text_.$TextType(), deleteOriginal: true),
        $a[1].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[2].castTo(const colorspace_.$ColorSpaceType(), deleteOriginal: true),
        $a[3].castTo(const jni.JArrayType(jni.JFloatType()),
            deleteOriginal: true),
        $a[4]
            .castTo(const jni.JDoubleType(), deleteOriginal: true)
            .doubleValue(deleteOriginal: true),
        $a[5]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"clipText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const text_.$TextType(), deleteOriginal: true),
        $a[1].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"strokeText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const text_.$TextType(), deleteOriginal: true),
        $a[1].castTo(const strokestate_.$StrokeStateType(),
            deleteOriginal: true),
        $a[2].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[3].castTo(const colorspace_.$ColorSpaceType(), deleteOriginal: true),
        $a[4].castTo(const jni.JArrayType(jni.JFloatType()),
            deleteOriginal: true),
        $a[5]
            .castTo(const jni.JDoubleType(), deleteOriginal: true)
            .doubleValue(deleteOriginal: true),
        $a[6]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"clipStrokeText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const text_.$TextType(), deleteOriginal: true),
        $a[1].castTo(const strokestate_.$StrokeStateType(),
            deleteOriginal: true),
        $a[2].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"ignoreText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const text_.$TextType(), deleteOriginal: true),
        $a[1].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"fillShade(Lcom/artifex/mupdf/fitz/Shade;Lcom/artifex/mupdf/fitz/Matrix;DI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const shade_.$ShadeType(), deleteOriginal: true),
        $a[1].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[2]
            .castTo(const jni.JDoubleType(), deleteOriginal: true)
            .doubleValue(deleteOriginal: true),
        $a[3]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"fillImage(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;DI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const image_.$ImageType(), deleteOriginal: true),
        $a[1].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[2]
            .castTo(const jni.JDoubleType(), deleteOriginal: true)
            .doubleValue(deleteOriginal: true),
        $a[3]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"fillImageMask(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const image_.$ImageType(), deleteOriginal: true),
        $a[1].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[2].castTo(const colorspace_.$ColorSpaceType(), deleteOriginal: true),
        $a[3].castTo(const jni.JArrayType(jni.JFloatType()),
            deleteOriginal: true),
        $a[4]
            .castTo(const jni.JDoubleType(), deleteOriginal: true)
            .doubleValue(deleteOriginal: true),
        $a[5]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"clipImageMask(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const image_.$ImageType(), deleteOriginal: true),
        $a[1].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"popClip()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    if ($d ==
        r"beginMask(Lcom/artifex/mupdf/fitz/Rect;ZLcom/artifex/mupdf/fitz/ColorSpace;[FI)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const rect_.$RectType(), deleteOriginal: true),
        $a[1]
            .castTo(const jni.JBooleanType(), deleteOriginal: true)
            .booleanValue(deleteOriginal: true),
        $a[2].castTo(const colorspace_.$ColorSpaceType(), deleteOriginal: true),
        $a[3].castTo(const jni.JArrayType(jni.JFloatType()),
            deleteOriginal: true),
        $a[4]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"endMask()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    if ($d ==
        r"beginGroup(Lcom/artifex/mupdf/fitz/Rect;Lcom/artifex/mupdf/fitz/ColorSpace;ZZIF)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const rect_.$RectType(), deleteOriginal: true),
        $a[1].castTo(const colorspace_.$ColorSpaceType(), deleteOriginal: true),
        $a[2]
            .castTo(const jni.JBooleanType(), deleteOriginal: true)
            .booleanValue(deleteOriginal: true),
        $a[3]
            .castTo(const jni.JBooleanType(), deleteOriginal: true)
            .booleanValue(deleteOriginal: true),
        $a[4]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
        $a[5]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"endGroup()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    if ($d ==
        r"beginTile(Lcom/artifex/mupdf/fitz/Rect;Lcom/artifex/mupdf/fitz/Rect;FFLcom/artifex/mupdf/fitz/Matrix;I)I") {
      final $r = _$methods[$p]![$d]!(
        $a[0].castTo(const rect_.$RectType(), deleteOriginal: true),
        $a[1].castTo(const rect_.$RectType(), deleteOriginal: true),
        $a[2]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[3]
            .castTo(const jni.JFloatType(), deleteOriginal: true)
            .floatValue(deleteOriginal: true),
        $a[4].castTo(const matrix_.$MatrixType(), deleteOriginal: true),
        $a[5]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return (jni.JInteger($r)..setAsDeleted()).reference;
    }
    if ($d == r"endTile()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    if ($d == r"renderFlags(II)V") {
      _$methods[$p]![$d]!(
        $a[0]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
        $a[1]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d ==
        r"setDefaultColorSpaces(Lcom/artifex/mupdf/fitz/DefaultColorSpaces;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const defaultcolorspaces_.$DefaultColorSpacesType(),
            deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"beginLayer(Ljava/lang/String;)V") {
      _$methods[$p]![$d]!(
        $a[0].castTo(const jni.JStringType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"endLayer()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    if ($d == r"beginStructure(ILjava/lang/String;I)V") {
      _$methods[$p]![$d]!(
        $a[0]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
        $a[1].castTo(const jni.JStringType(), deleteOriginal: true),
        $a[2]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"endStructure()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    if ($d == r"beginMetatext(ILjava/lang/String;)V") {
      _$methods[$p]![$d]!(
        $a[0]
            .castTo(const jni.JIntegerType(), deleteOriginal: true)
            .intValue(deleteOriginal: true),
        $a[1].castTo(const jni.JStringType(), deleteOriginal: true),
      );
      return jni.nullptr;
    }
    if ($d == r"endMetatext()V") {
      _$methods[$p]![$d]!();
      return jni.nullptr;
    }
    return jni.nullptr;
  }

  factory DeviceInterface.implement({
    required void Function() close,
    required void Function(
            path_.Path path,
            bool z,
            matrix_.Matrix matrix,
            colorspace_.ColorSpace colorSpace,
            jni.JArray<jni.jfloat> fs,
            double f,
            int i)
        fillPath,
    required void Function(path_.Path path, bool z, matrix_.Matrix matrix)
        clipPath,
    required void Function(
            path_.Path path,
            strokestate_.StrokeState strokeState,
            matrix_.Matrix matrix,
            colorspace_.ColorSpace colorSpace,
            jni.JArray<jni.jfloat> fs,
            double f,
            int i)
        strokePath,
    required void Function(path_.Path path,
            strokestate_.StrokeState strokeState, matrix_.Matrix matrix)
        clipStrokePath,
    required void Function(
            text_.Text text,
            matrix_.Matrix matrix,
            colorspace_.ColorSpace colorSpace,
            jni.JArray<jni.jfloat> fs,
            double f,
            int i)
        fillText,
    required void Function(text_.Text text, matrix_.Matrix matrix) clipText,
    required void Function(
            text_.Text text,
            strokestate_.StrokeState strokeState,
            matrix_.Matrix matrix,
            colorspace_.ColorSpace colorSpace,
            jni.JArray<jni.jfloat> fs,
            double f,
            int i)
        strokeText,
    required void Function(text_.Text text,
            strokestate_.StrokeState strokeState, matrix_.Matrix matrix)
        clipStrokeText,
    required void Function(text_.Text text, matrix_.Matrix matrix) ignoreText,
    required void Function(
            shade_.Shade shade, matrix_.Matrix matrix, double f, int i)
        fillShade,
    required void Function(
            image_.Image image, matrix_.Matrix matrix, double f, int i)
        fillImage,
    required void Function(
            image_.Image image,
            matrix_.Matrix matrix,
            colorspace_.ColorSpace colorSpace,
            jni.JArray<jni.jfloat> fs,
            double f,
            int i)
        fillImageMask,
    required void Function(image_.Image image, matrix_.Matrix matrix)
        clipImageMask,
    required void Function() popClip,
    required void Function(rect_.Rect rect, bool z,
            colorspace_.ColorSpace colorSpace, jni.JArray<jni.jfloat> fs, int i)
        beginMask,
    required void Function() endMask,
    required void Function(rect_.Rect rect, colorspace_.ColorSpace colorSpace,
            bool z, bool z1, int i, double f)
        beginGroup,
    required void Function() endGroup,
    required int Function(rect_.Rect rect, rect_.Rect rect1, double f,
            double f1, matrix_.Matrix matrix, int i)
        beginTile,
    required void Function() endTile,
    required void Function(int i, int i1) renderFlags,
    required void Function(
            defaultcolorspaces_.DefaultColorSpaces defaultColorSpaces)
        setDefaultColorSpaces,
    required void Function(jni.JString s) beginLayer,
    required void Function() endLayer,
    required void Function(int i, jni.JString s, int i1) beginStructure,
    required void Function() endStructure,
    required void Function(int i, jni.JString s) beginMetatext,
    required void Function() endMetatext,
  }) {
    final $p = ReceivePort();
    final $x = DeviceInterface.fromRef(
      ProtectedJniExtensions.newPortProxy(
        r"com.gergovari.mupdf.DeviceInterface",
        $p,
        _$invokePointer,
      ),
    ).._$p = $p;
    final $a = $p.sendPort.nativePort;
    _$types[$a] = {};
    _$methods[$a] = {};
    _$methods[$a]![r"close()V"] = close;
    _$methods[$a]![
            r"fillPath(Lcom/artifex/mupdf/fitz/Path;ZLcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V"] =
        fillPath;
    _$methods[$a]![
            r"clipPath(Lcom/artifex/mupdf/fitz/Path;ZLcom/artifex/mupdf/fitz/Matrix;)V"] =
        clipPath;
    _$methods[$a]![
            r"strokePath(Lcom/artifex/mupdf/fitz/Path;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V"] =
        strokePath;
    _$methods[$a]![
            r"clipStrokePath(Lcom/artifex/mupdf/fitz/Path;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;)V"] =
        clipStrokePath;
    _$methods[$a]![
            r"fillText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V"] =
        fillText;
    _$methods[$a]![
            r"clipText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;)V"] =
        clipText;
    _$methods[$a]![
            r"strokeText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V"] =
        strokeText;
    _$methods[$a]![
            r"clipStrokeText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/StrokeState;Lcom/artifex/mupdf/fitz/Matrix;)V"] =
        clipStrokeText;
    _$methods[$a]![
            r"ignoreText(Lcom/artifex/mupdf/fitz/Text;Lcom/artifex/mupdf/fitz/Matrix;)V"] =
        ignoreText;
    _$methods[$a]![
            r"fillShade(Lcom/artifex/mupdf/fitz/Shade;Lcom/artifex/mupdf/fitz/Matrix;DI)V"] =
        fillShade;
    _$methods[$a]![
            r"fillImage(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;DI)V"] =
        fillImage;
    _$methods[$a]![
            r"fillImageMask(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;Lcom/artifex/mupdf/fitz/ColorSpace;[FDI)V"] =
        fillImageMask;
    _$methods[$a]![
            r"clipImageMask(Lcom/artifex/mupdf/fitz/Image;Lcom/artifex/mupdf/fitz/Matrix;)V"] =
        clipImageMask;
    _$methods[$a]![r"popClip()V"] = popClip;
    _$methods[$a]![
            r"beginMask(Lcom/artifex/mupdf/fitz/Rect;ZLcom/artifex/mupdf/fitz/ColorSpace;[FI)V"] =
        beginMask;
    _$methods[$a]![r"endMask()V"] = endMask;
    _$methods[$a]![
            r"beginGroup(Lcom/artifex/mupdf/fitz/Rect;Lcom/artifex/mupdf/fitz/ColorSpace;ZZIF)V"] =
        beginGroup;
    _$methods[$a]![r"endGroup()V"] = endGroup;
    _$methods[$a]![
            r"beginTile(Lcom/artifex/mupdf/fitz/Rect;Lcom/artifex/mupdf/fitz/Rect;FFLcom/artifex/mupdf/fitz/Matrix;I)I"] =
        beginTile;
    _$methods[$a]![r"endTile()V"] = endTile;
    _$methods[$a]![r"renderFlags(II)V"] = renderFlags;
    _$methods[$a]![
            r"setDefaultColorSpaces(Lcom/artifex/mupdf/fitz/DefaultColorSpaces;)V"] =
        setDefaultColorSpaces;
    _$methods[$a]![r"beginLayer(Ljava/lang/String;)V"] = beginLayer;
    _$methods[$a]![r"endLayer()V"] = endLayer;
    _$methods[$a]![r"beginStructure(ILjava/lang/String;I)V"] = beginStructure;
    _$methods[$a]![r"endStructure()V"] = endStructure;
    _$methods[$a]![r"beginMetatext(ILjava/lang/String;)V"] = beginMetatext;
    _$methods[$a]![r"endMetatext()V"] = endMetatext;
    _$finalizer.attach($x, $p, detach: $x);
    $p.listen(($m) {
      final $i = $MethodInvocation.fromMessage($m);
      final $r = _$invokeMethod($p.sendPort.nativePort, $i);
      ProtectedJniExtensions.returnResult($i.result, $r);
    });
    return $x;
  }
}

class $DeviceInterfaceType extends jni.JObjType<DeviceInterface> {
  const $DeviceInterfaceType();

  @override
  String get signature => r"Lcom/gergovari/mupdf/DeviceInterface;";

  @override
  DeviceInterface fromRef(jni.JObjectPtr ref) => DeviceInterface.fromRef(ref);

  @override
  jni.JObjType get superType => const jni.JObjectType();

  @override
  final superCount = 1;

  @override
  int get hashCode => ($DeviceInterfaceType).hashCode;

  @override
  bool operator ==(Object other) {
    return other.runtimeType == ($DeviceInterfaceType) &&
        other is $DeviceInterfaceType;
  }
}
